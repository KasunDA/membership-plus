//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool
//     Tool name: CGW X-Script Linq to SQL Layer Generator
//
//     Archymeta Information Technologies Co., Ltd.
//
//     Changes to this file, especially those bit flags, may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Configuration;
using System.Data.Linq;
using System.Data.Linq.Mapping;
using System.Data;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Reflection;
using System.Linq;
using System.Linq.Expressions;
using System.ComponentModel;
using System.ServiceModel;
using System.ServiceModel.Channels;

namespace CryptoGateway.RDB.Data.MembershipPlus
{
    /// <summary>
    /// Proxy for <see cref="IEventLogService2" /> service.
    /// </summary>
    /// <remarks>
    ///  <para>
    ///    Methods of the service are categorized in the following:
    ///  </para>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Adding, Updating or Removing</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///         Adding, updating or removing entity graphs to or from data source.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="EventLogServiceProxy.AddOrUpdateEntities" />, <see cref="EventLogServiceProxy.EnqueueNewOrUpdateEntities" />, and <see cref="EventLogServiceProxy.DeleteEntities" />.
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Paged Listing</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///         Provides paged listing of query results.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="EventLogServiceProxy.NextPageBlock" /> and <see cref="EventLogServiceProxy.GetPageItems" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Querying</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Query the data source.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="EventLogServiceProxy.QueryEntityCount" />, <see cref="EventLogServiceProxy.QueryDatabase" />, <see cref="EventLogServiceProxy.QueryDatabaseLimited" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Entity Lookup</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Find an entity from the corresponding entity set.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="EventLogServiceProxy.LoadEntityByKey" /> and <see cref="EventLogServiceProxy.LoadEntityByNature" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Conditioned Querying</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        When entities in an entity set depends on entities in other sets, query the data source under condition that some or all the entities that the current entity set depends on
    ///      are given.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="EventLogServiceProxy.ConstraintQueryEntityCount" />, <see cref="EventLogServiceProxy.ConstraintQuery" />, <see cref="EventLogServiceProxy.ConstraintQueryLimited" />,
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Querying Intelligency</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///         Provides a self-complete system for clients to construct query expressions. What completeness means here is that all options are included and 
    ///      no extra (to the query system) options are present.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///         <see cref="EventLogServiceProxy.GetNextSorterOps" /> and <see cref="EventLogServiceProxy.GetNextFilterOps" />.
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Delay Loaded Properties</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Properties that are loaded on demand.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods (loading)</term>
    ///      <description>
    ///         <see cref="EventLogServiceProxy.LoadEntityExceptionInfo" />, <see cref="EventLogServiceProxy.LoadEntityMessageLong" />
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods (uploading)</term>
    ///      <description>
    ///         
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Upstream Navigation</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Load and/or navigates to entities an entity in the current entity set depends upon.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///        <see cref="EventLogServiceProxy.MaterializeApplication_Ref" />.
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Downstream Navigation</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Load and/or navigates to entity sets that depend on an entity in the current entity set.
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///        <see cref="EventLogServiceProxy.MaterializeEventLocations" />.
    ///      </description>
    ///    </item>
    ///  </list>
    ///  <list type="table">
    ///    <listheader>
    ///       <term>Entity graph building</term><description></description>
    ///    </listheader>
    ///    <item>
    ///      <term>Description</term>
    ///      <description>
    ///        Load a selected entity graph from the data source starting at an entity having specified primary key(s)
    ///      </description>
    ///    </item>
    ///    <item>
    ///      <term>Methods</term>
    ///      <description>
    ///        <see cref="EventLogServiceProxy.LoadEntityGraphRecurs" />.
    ///      </description>
    ///    </item>
    ///  </list>
    /// </remarks>
    public class EventLogServiceProxy : ClientBase<IEventLogService2>, IEventLogService2
    {
        /// <summary>
        /// Constructor.
        /// </summary>
        public EventLogServiceProxy() 
            : base("HTTP")
        {

        }

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="svcConfig">The name of the configuration node for the end point.</param>
        public EventLogServiceProxy(string svcConfig) 
            : base(svcConfig)
        {

        }

        /// <summary>
        /// Initializes a new instance using the specified binding and target address. 
        /// </summary>
        /// <param name="binding">The binding with which to make calls to the service.</param>
        /// <param name="remoteAddress">The address of the service endpoint.</param>
        public EventLogServiceProxy(Binding binding, EndpointAddress remoteAddress)
            : base(binding, remoteAddress)
        {

        }

        /// <summary>
        /// Client attached error handler.
        /// </summary>
        public Action<Exception> DelHandleError = null;
        /// <summary>
        ///   Retrieve information about the entity set: "EventLogs". 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="filter">Filter expression for the current set.</param>
        /// <returns>
        ///   Entity set: <see cref="EventLogSet" /> data model.
        /// </returns>
        public EventLogSet GetSetInfo(CallContext cntx, string filter)
        {
            try
            {
                return Channel.GetSetInfo(cntx, filter);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Retrieve information about the entity set: "EventLogs". Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="filter">Filter expression for the current set.</param>
        /// <returns>
        ///   Entity set: <see cref="EventLogSet" /> data model.
        /// </returns>
        public async System.Threading.Tasks.Task<EventLogSet> GetSetInfoAsync(CallContext cntx, string filter)
        {
            try
            {
                return await Channel.GetSetInfoAsync(cntx, filter);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Add or update a set of entities to the entity set. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side),
        ///  the update will be rejected unless the client set the <see cref="CallContext.OverrideExisting" /> property  of "cntx" to <c>true</c>. </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add operations. 
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="EventLog" />) is modified or its <see cref="EventLog.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Clients can set some of the member entities in { <see cref="EventLog.Application_Ref" /> } that an currently added or updated entity depends upon. These additional entities will be 
        ///  add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  Clients can also create and add to member collections in { <see cref="EventLog.ChangedEventLocations" /> } entities that depends on an currently added or updated entity. These 
        ///  additional entities will be add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="ChangeOpResults{T}" /> which contains operation messages, if any, and a list of successfully added or updated entities.
        /// </returns>
        public ChangeOpResults<EventLogUpdateResult> AddOrUpdateEntities(CallContext cntx, EventLogSet set, EventLog[] entities)
        {
            try
            {
                return Channel.AddOrUpdateEntities(cntx, set, entities);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Add or update a set of entities to the entity set. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side),
        ///  the update will be rejected unless the client set the <see cref="CallContext.OverrideExisting" /> property  of "cntx" to <c>true</c>. </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add operations. 
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="EventLog" />) is modified or its <see cref="EventLog.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Clients can set some of the member entities in { <see cref="EventLog.Application_Ref" /> } that an currently added or updated entity depends upon. These additional entities will be 
        ///  add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  Clients can also create and add to member collections in { <see cref="EventLog.ChangedEventLocations" /> } entities that depends on an currently added or updated entity. These 
        ///  additional entities will be add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="ChangeOpResults{T}" /> which contains operation messages, if any, and a list of successfully added or updated entities.
        /// </returns>
        public async System.Threading.Tasks.Task<ChangeOpResults<EventLogUpdateResult>> AddOrUpdateEntitiesAsync(CallContext cntx, EventLogSet set, EventLog[] entities)
        {
            try
            {
                return await Channel.AddOrUpdateEntitiesAsync(cntx, set, entities);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Queue a set of entities to be added or updated to the entity set in a certain preset future time. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The processing will be delayed to be started at a certain future time. If there are any further calls to this method during the wait period, the new sets will be 
        ///  merged with existing ones inside the queue. This method is useful when there are repetitive updates to the entity set but the actual change history is not of 
        ///  interest to the client, namely only the last snapshot of the changes are relevent. In this case, the method can reduce the loads on the backend data source 
        ///  significantly.
        ///  </para>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set when the processing starts. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side), 
        ///  the update will be rejected unless the client set the <c>OverrideExisting</c> property  of "cntx" to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add or update operations, namely they will always be added to the set.
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="EventLog" />) is modified or its <see cref="EventLog.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Warning: Please do not use this method when new entities are to be added and information about these updated enitities, like auto generated primary keys, are needed for 
        ///  proceeding to the next steps.
        ///  </para>
        ///  <para>
        ///  Clients can set some of the member entities in { <see cref="EventLog.ChangedEventLocations" /> } that an currently added or updated entity depends upon. These additional entities will be 
        ///  add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        /// </returns>
        public void EnqueueNewOrUpdateEntities(CallContext cntx, EventLogSet set, EventLog[] entities)
        {
            try
            {
                Channel.EnqueueNewOrUpdateEntities(cntx, set, entities);
            }
            catch (Exception ex)
            {
                HandleError(ex);
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Queue a set of entities to be added or updated to the entity set in a certain preset future time. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///  The processing will be delayed to be started at a certain future time. If there are any further calls to this method during the wait period, the new sets will be 
        ///  merged with existing ones inside the queue. This method is useful when there are repetitive updates to the entity set but the actual change history is not of 
        ///  interest to the client, namely only the last snapshot of the changes are relevent. In this case, the method can reduce the loads on the backend data source 
        ///  significantly.
        ///  </para>
        ///  <para>
        ///  The list of entities will be checked against existing ones inside the entity set when the processing starts. An entity is identified by a set of "intrinsic identitfiers" selected
        ///  when the system is generated. They are not necessarily the same as primary keys of the set. An auto generated primary key can not be
        ///  used as an "intrinsic identitfier". An entity having the same set of "intrinsic identitfiers" can not be added to the database. They will be treated 
        ///  as an entity update if the client load the entity first before modifying it, otherwise (namely if the client created the entity on the client side), 
        ///  the update will be rejected unless the client set the <c>OverrideExisting</c> property  of "cntx" to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Note: entities having no "intrinsic identitfier" will always be treated as different entities in add or update operations, namely they will always be added to the set.
        ///  </para>
        ///  <para>
        ///  Note 2: A persisted entity (namely the one loaded
        ///  from the data set) will be ignored in if none of its editable properties (set before system generation, see
        ///  <see cref="EventLog" />) is modified or its <see cref="EventLog.IsEntityChanged" /> property is
        ///  not set to <c>true</c>. 
        ///  </para>
        ///  <para>
        ///  Warning: Please do not use this method when new entities are to be added and information about these updated enitities, like auto generated primary keys, are needed for 
        ///  proceeding to the next steps.
        ///  </para>
        ///  <para>
        ///  Clients can set some of the member entities in { <see cref="EventLog.ChangedEventLocations" /> } that an currently added or updated entity depends upon. These additional entities will be 
        ///  add or updated to the data source following the same logic, all the object relationships will be properly setup if the operation is successful.
        ///  </para>
        ///  <para>
        ///  In general, a client can construct an object graph of any complexity following the above rules and have it added or updated to the data source in one step.
        ///  </para>
        /// </remarks>
        /// <returns>
        /// </returns>
        public async System.Threading.Tasks.Task EnqueueNewOrUpdateEntitiesAsync(CallContext cntx, EventLogSet set, EventLog[] entities)
        {
            try
            {
                await Channel.EnqueueNewOrUpdateEntitiesAsync(cntx, set, entities);
            }
            catch (Exception ex)
            {
                HandleError(ex);
            }
        }
#endif

        /// <summary>
        ///  Delete a set of entities from the entity set, together with all their dependents, recursively. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///   Care should be taken when deleting an entire inter-dependent object sub-graph.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="OperationResults" /> which contains operation messages, if any.
        /// </returns>
        public OperationResults DeleteEntities(CallContext cntx, EventLogSet set, EventLog[] entities)
        {
            try
            {
                return Channel.DeleteEntities(cntx, set, entities);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///  Delete a set of entities from the entity set, together with all their dependents, recursively. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">The current entity set.</param>
        /// <param name="entities">The list of entities to be processed.</param>
        /// <remarks>
        ///  <para>
        ///   Care should be taken when deleting an entire inter-dependent object sub-graph.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Operation result contained inside an object of type <see cref="OperationResults" /> which contains operation messages, if any.
        /// </returns>
        public async System.Threading.Tasks.Task<OperationResults> DeleteEntitiesAsync(CallContext cntx, EventLogSet set, EventLog[] entities)
        {
            try
            {
                return await Channel.DeleteEntitiesAsync(cntx, set, entities);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Get a block of page frames from the entity set "EventLogs" of the data source under specified filtering and sorting conditions. 
        /// </summary>
        /// <remarks>
        /// The page size and the page block size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page block. For the first page block, it is set to null value.</param>
        /// <returns>
        ///   <see cref="EventLogPageBlock" /> data model for entity set "EventLogs".
        /// </returns>
        public EventLogPageBlock NextPageBlock(CallContext cntx, EventLogSet set, QueryExpresion qexpr, EventLog prevlast)
        {
            try
            {
                if (prevlast != null)
                   prevlast  = prevlast.ShallowCopy();
                return Channel.NextPageBlock(cntx, set, qexpr, prevlast);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC

        /// <summary>
        ///   Get a block of page frames from the entity set "EventLogs" of the data source under specified filtering and sorting conditions. Awaitable asynchronous version.
        /// </summary>
        /// <remarks>
        /// The page size and the page block size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page block. For the first page block, it is set to null value.</param>
        /// <returns>
        ///   <see cref="EventLogPageBlock" /> data model for entity set "EventLogs".
        /// </returns>
        public async System.Threading.Tasks.Task<EventLogPageBlock> NextPageBlockAsync(CallContext cntx, EventLogSet set, QueryExpresion qexpr, EventLog prevlast)
        {
            try
            {
                if (prevlast != null)
                   prevlast  = prevlast.ShallowCopy();
                return await Channel.NextPageBlockAsync(cntx, set, qexpr, prevlast);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load entities of a page from the entity set "EventLogs" of the data source under specified filtering and sorting conditions. 
        /// </summary>
        /// <remarks>
        /// The page size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page. For the first page, it is set to null value.</param>
        /// <returns>
        ///   Collection of <see cref="EventLog" /> in set "EventLogs" for the current page defined by "prevlast".
        /// </returns>
        public IEnumerable<EventLog> GetPageItems(CallContext cntx, EventLogSet set, QueryExpresion qexpr, EventLog prevlast)
        {
            try
            {
                if (prevlast != null)
                   prevlast  = prevlast.ShallowCopy();
                return Channel.GetPageItems(cntx, set, qexpr, prevlast).Select(d => { d.StartAutoUpdating = true; return d; });
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC

        /// <summary>
        ///   Load entities of a page from the entity set "EventLogs" of the data source under specified filtering and sorting conditions. Awaitable asynchronous version.
        /// </summary>
        /// <remarks>
        /// The page size is specified inside "set".
        /// </remarks>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="prevlast">The last entity inside the previous page. For the first page, it is set to null value.</param>
        /// <returns>
        ///   Collection of <see cref="EventLog" /> in set "EventLogs" for the current page defined by "prevlast".
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<EventLog>> GetPageItemsAsync(CallContext cntx, EventLogSet set, QueryExpresion qexpr, EventLog prevlast)
        {
            try
            {
                if (prevlast != null)
                   prevlast  = prevlast.ShallowCopy();
                return (await Channel.GetPageItemsAsync(cntx, set, qexpr, prevlast)).Select(d => { d.StartAutoUpdating = true; return d; });
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Count the number of entities inside entity set "EventLogs" of the data source under specified filtering condition. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The number of entities.
        /// </returns>
        public Int64 QueryEntityCount(CallContext cntx, EventLogSet set, QueryExpresion qexpr)
        {
            try
            {
                return Channel.QueryEntityCount(cntx, set, qexpr);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return default(Int64);
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Count the number of entities inside entity set "EventLogs" of the data source under specified filtering condition. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The number of entities.
        /// </returns>
        public async System.Threading.Tasks.Task<Int64> QueryEntityCountAsync(CallContext cntx, EventLogSet set, QueryExpresion qexpr)
        {
            try
            {
                return await Channel.QueryEntityCountAsync(cntx, set, qexpr);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return default(Int64);
            }
        }
#endif

        /// <summary>
        ///   Get the collection of entities of type <see cref="EventLog" /> inside entity set "EventLogs" of the data source under specified filtering and sorting conditions. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        public IEnumerable<EventLog> QueryDatabase(CallContext cntx, EventLogSet set, QueryExpresion qexpr)
        {
            try
            {
                return Channel.QueryDatabase(cntx, set, qexpr).Select(d => { d.StartAutoUpdating = true; return d; });
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Get the collection of entities of type <see cref="EventLog" /> inside entity set "EventLogs" of the data source under specified filtering and sorting conditions. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<EventLog>> QueryDatabaseAsync(CallContext cntx, EventLogSet set, QueryExpresion qexpr)
        {
            try
            {
                return (await Channel.QueryDatabaseAsync(cntx, set, qexpr)).Select(d => { d.StartAutoUpdating = true; return d; });
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Get the collection of entities of type <see cref="EventLog" /> inside entity set "EventLogs" from the data source under specified filtering, sorting and max number of returning entities conditions. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="maxRecords">Max number of entities to return.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        public IEnumerable<EventLog> QueryDatabaseLimited(CallContext cntx, EventLogSet set, QueryExpresion qexpr, int maxRecords)
        {
            try
            {
                return Channel.QueryDatabaseLimited(cntx, set, qexpr, maxRecords).Select(d => { d.StartAutoUpdating = true; return d; });
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Get the collection of entities of type <see cref="EventLog" /> inside entity set "EventLogs" from the data source under specified filtering, sorting and max number of returning entities conditions. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="maxRecords">Max number of entities to return.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<EventLog>> QueryDatabaseLimitedAsync(CallContext cntx, EventLogSet set, QueryExpresion qexpr, int maxRecords)
        {
            try
            {
                return (await Channel.QueryDatabaseLimitedAsync(cntx, set, qexpr, maxRecords)).Select(d => { d.StartAutoUpdating = true; return d; });
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Get the number of entities from the data source restricted by a set of specified foreign key values and under specified filtering, sorting conditions. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="constraints">A set of foreign key wrapper pointing to primary keys of the sets that "EventLogs" depends upon. If a user do not wish to set a contraint for it, then set it to null, </param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The number of entities.
        /// </returns>
        public Int64 ConstraintQueryEntityCount(CallContext cntx, EventLogSet set, EventLogSetConstraints constraints, QueryExpresion qexpr)
        {
            try
            {
                return Channel.ConstraintQueryEntityCount(cntx, set, constraints, qexpr);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return default(Int64);
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Get the number of entities from the data source restricted by a set of specified foreign key values and under specified filtering, sorting conditions. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="constraints">A set of foreign key wrapper pointing to primary keys of the sets that "EventLogs" depends upon. If a user do not wish to set a contraint for it, then set it to null, </param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The number of entities.
        /// </returns>
        public async System.Threading.Tasks.Task<Int64> ConstraintQueryEntityCountAsync(CallContext cntx, EventLogSet set, EventLogSetConstraints constraints, QueryExpresion qexpr)
        {
            try
            {
                return await Channel.ConstraintQueryEntityCountAsync(cntx, set, constraints, qexpr);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return default(Int64);
            }
        }
#endif

        /// <summary>
        ///   Given a set of foreign key constraints, find the ones that has non zero corresponding entities. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="cnstSets">A collection of sets of foreign key wrapper pointing to primary keys of the sets that "EventLogs" depends upon. If a user do not wish to set a contraint for it, then set it to null, </param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   A set of constraint pointer that has non-zero corresponding entities.
        /// </returns>
        public ConstraintsPtr[] ConstraintsFindMatches(CallContext cntx, EventLogSet set, EventLogSetConstraints[] cnstSets, QueryExpresion qexpr)
        {
            try
            {
                return Channel.ConstraintsFindMatches(cntx, set, cnstSets, qexpr);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Given a set of foreign key constraints, find the ones that has non zero corresponding entities. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="cnstSets">A collection of sets of foreign key wrapper pointing to primary keys of the sets that "EventLogs" depends upon. If a user do not wish to set a contraint for it, then set it to null, </param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   A set of constraint pointer that has non-zero corresponding entities.
        /// </returns>
        public async System.Threading.Tasks.Task<ConstraintsPtr[]> ConstraintsFindMatchesAsync(CallContext cntx, EventLogSet set, EventLogSetConstraints[] cnstSets, QueryExpresion qexpr)
        {
            try
            {
                return await Channel.ConstraintsFindMatchesAsync(cntx, set, cnstSets, qexpr);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Get the collection of entities of type <see cref="EventLog" /> inside entity set "EventLogs" from the data source restricted by a set of specified foreign key values and under specified filtering, sorting conditions. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="constraints">A set of foreign key wrapper pointing to primary keys of the sets that "EventLogs" depends upon. If a user do not wish to set a contraint for it, then set it to null, </param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        public IEnumerable<EventLog> ConstraintQuery(CallContext cntx, EventLogSet set, EventLogSetConstraints constraints, QueryExpresion qexpr)
        {
            try
            {
                return Channel.ConstraintQuery(cntx, set, constraints, qexpr).Select(d => { d.StartAutoUpdating = true; return d; });
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Get the collection of entities of type <see cref="EventLog" /> inside entity set "EventLogs" from the data source restricted by a set of specified foreign key values and under specified filtering, sorting conditions. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="constraints">A set of foreign key wrapper pointing to primary keys of the sets that "EventLogs" depends upon. If a user do not wish to set a contraint for it, then set it to null, </param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<EventLog>> ConstraintQueryAsync(CallContext cntx, EventLogSet set, EventLogSetConstraints constraints, QueryExpresion qexpr)
        {
            try
            {
                return (await Channel.ConstraintQueryAsync(cntx, set, constraints, qexpr)).Select(d => { d.StartAutoUpdating = true; return d; });
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Get the collection of entities of type <see cref="EventLog" /> inside entity set "EventLogs" of the data source restricted by a set of specified foreign key values and under specified filtering, sorting and max number of returning entities conditions. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="constraints">A set of foreign key wrapper pointing to primary keys of the sets that "EventLogs" depends upon. If a user do not wish to set a contraint for it, then set it to null, </param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="maxRecords">Max number of entities to return.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        public IEnumerable<EventLog> ConstraintQueryLimited(CallContext cntx, EventLogSet set, EventLogSetConstraints constraints, QueryExpresion qexpr, int maxRecords)
        {
            try
            {
                return Channel.ConstraintQueryLimited(cntx, set, constraints, qexpr, maxRecords).Select(d => { d.StartAutoUpdating = true; return d; });
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Get the collection of entities of type <see cref="EventLog" /> inside entity set "EventLogs" of the data source restricted by a set of specified foreign key values and under specified filtering, sorting and max number of returning entities conditions. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="set">Set information.</param>
        /// <param name="constraints">A set of foreign key wrapper pointing to primary keys of the sets that "EventLogs" depends upon. If a user do not wish to set a contraint for it, then set it to null, </param>
        /// <param name="qexpr">Tokenized querying and sorting expression.</param>
        /// <param name="maxRecords">Max number of entities to return.</param>
        /// <returns>
        ///   The collection of entities.
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<EventLog>> ConstraintQueryLimitedAsync(CallContext cntx, EventLogSet set, EventLogSetConstraints constraints, QueryExpresion qexpr, int maxRecords)
        {
            try
            {
                return (await Channel.ConstraintQueryLimitedAsync(cntx, set, constraints, qexpr, maxRecords)).Select(d => { d.StartAutoUpdating = true; return d; });
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the entity "Application_Ref" of type <see cref="Application_" /> that the entity depend upon. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        /// If the corresponding foreign key is nullable, the returned entity can be null.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="Application_" /> or null.
        /// </returns>
        public Application_ MaterializeApplication_Ref(CallContext cntx, EventLog entity)
        {
            try
            {
                var e = Channel.MaterializeApplication_Ref(cntx, entity.ShallowCopy()); 
                if (e != null)
                    e.StartAutoUpdating = true;
                return e;
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the entity "Application_Ref" of type <see cref="Application_" /> that the entity depend upon. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        /// If the corresponding foreign key is nullable, the returned entity can be null.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="Application_" /> or null.
        /// </returns>
        public async System.Threading.Tasks.Task<Application_> MaterializeApplication_RefAsync(CallContext cntx, EventLog entity)
        {
            try
            {
                var e = await Channel.MaterializeApplication_RefAsync(cntx, entity.ShallowCopy());
                if (e != null)
                    e.StartAutoUpdating = true;
                return e;
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the set of depending entities "EventLocations" of type <see cref="EventLocationSet" /> of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="EventLocationSet" />.
        /// </returns>
        public EventLocationSet MaterializeEventLocations(CallContext cntx, EventLog entity)
        {
            try
            {
                return Channel.MaterializeEventLocations(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the set of depending entities "EventLocations" of type <see cref="EventLocationSet" /> of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <remarks>
        ///  The set returned is a filtered subset whose members are all depending on the entity.
        /// </remarks>
        /// <returns>
        ///   An entity of type <see cref="EventLocationSet" />.
        /// </returns>
        public async System.Threading.Tasks.Task<EventLocationSet> MaterializeEventLocationsAsync(CallContext cntx, EventLog entity)
        {
            try
            {
                return await Channel.MaterializeEventLocationsAsync(cntx, entity.ShallowCopy());
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///   Load the collection of depending entities "AllEventLocations" of type <see cref="IEnumerable{EventLocation}" /> (T = <see cref="EventLocation" />) of the entity. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{EventLocation}" /> (T = <see cref="EventLocation" />).
        /// </returns>
        public IEnumerable<EventLocation> MaterializeAllEventLocations(CallContext cntx, EventLog entity)
        {
            try
            {
                return Channel.MaterializeAllEventLocations(cntx, entity.ShallowCopy()).Select(d => { d.StartAutoUpdating = true; return d; });
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///   Load the collection of depending entities "AllEventLocations" of type <see cref="IEnumerable{EventLocation}" /> (T = <see cref="EventLocation" />) of the entity. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="entity">The entity.</param>
        /// <returns>
        ///   An collecton of type <see cref="IEnumerable{EventLocation}" /> (T = <see cref="EventLocation" />).
        /// </returns>
        public async System.Threading.Tasks.Task<IEnumerable<EventLocation>> MaterializeAllEventLocationsAsync(CallContext cntx, EventLog entity)
        {
            try
            {
                return (await Channel.MaterializeAllEventLocationsAsync(cntx, entity.ShallowCopy())).Select(d => { d.StartAutoUpdating = true; return d; });
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///  Load an entity from the entity set having specified primary key(s): { <see cref="EventLog.ID" /> }. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="EventLog.ID" />.</param>
        /// <returns>
        ///   Null or the entity found.
        /// </returns>
        public EventLog LoadEntityByKey(CallContext cntx, string _ID)
        {
            try
            {
                var e = Channel.LoadEntityByKey(cntx, _ID);
                if (e != null)
                    e.StartAutoUpdating = true;
                return e;
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///  Load an entity from the entity set having specified primary key(s): { <see cref="EventLog.ID" /> }. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="EventLog.ID" />.</param>
        /// <returns>
        ///   Null or the entity found.
        /// </returns>
        public async System.Threading.Tasks.Task<EventLog> LoadEntityByKeyAsync(CallContext cntx, string _ID)
        {
            try
            {
                var e = await Channel.LoadEntityByKeyAsync(cntx, _ID);
                if (e != null)
                    e.StartAutoUpdating = true;
                return e;
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///  Load a selected entity graph from the data source starting at an entity having specified primary key(s): { <see cref="EventLog.ID" /> }. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="EventLog.ID" />.</param>
        /// <param name="excludedSets">A list of sets to be excluded. </param>
        /// <param name="futherDrillSets">A list of sets above the entry set that are to be drilled down futher (see the following). </param>
        /// <remarks>
        /// <para>Relational databases are designed to serve as data query and storage backend, in a normalized way, for certain kind of applications. 
        /// However at the application level, normalized elementary data sets are often combined (jointed) in a user friendly way as views. In the object oriented 
        /// world and at the data view model level, these views can be represented using entity graphs.</para>
        /// <para>This method is designed to load a selected sub entity graph recursively from the data source in one call to the service starting with a given entity (id).
        /// It could be used to increase performance and to reduce client code complexity, sometimes significantly.</para>
        /// <para>The selection is controlled by two parameters, namely <paramref name="excludedSets" /> and <paramref name="futherDrillSets" />.</para>
        /// <para>The <paramref name="excludedSets" /> parameter is used to exclude a list of entity sets and all other sets that depend on it. This can be
        /// better understood if one has a look at the schematic view of the data set schema that is shown on the front page of the data service, namely
        /// if one date set (node) is excluded then all the sets that it points to will not be reached through it, although some of them could still be reached
        /// following other routes. </para>
        /// <para>There are many ways an entity sub-graph can be loaded, the present implementation is based on the rule to be given next. Namely, starting from 
        /// the entry element, it loads all entities that depends on it, recursively downward (namely following the arrows in the schema view). It also loads all 
        /// elements that any of the elements visited by the downward recursion depends upon, recursively upward (namely in 
        /// the opposite direction of the arrows in the schema view), but never go downward again without explicit instruction.</para>
        /// <para>The <paramref name="futherDrillSets" /> parameter is used control when to go downward again, represented by the <see cref="EntitySetRelation.SetType" /> member 
        /// and the collection of data sets that depend on it, represented by the <see cref="EntitySetRelation.RelatedSets" /> member, should be further drilled down, recursively.</para>
        /// <para>Note that a data service has intrinsic limits that do not allow transmitting an entity graph that is too large in one call, so one has to select which part
        /// of the entire graph should be loaded in each call to the data service,</para>
        /// <para>For a given entity, the entities that it depends upon are represented by the member objects corresponding to each foreign keys. However, the
        /// sets of entities that depend on the said entity are stored into the corresponding collection members having the "Changed" prefix and
        /// these entities do not have a back reference to the said entity to avoid circular references when doing serialization, Such back references can be
        /// added after the graph is materialized on the clients side, if needed.</para>
        /// </remarks>
        /// <returns>
        ///   Null or the entity graph found.
        /// </returns>
        public EventLog LoadEntityGraphRecurs(CallContext cntx, string _ID, EntitySetType[] excludedSets, EntitySetRelation[] futherDrillSets)
        {
            try
            {
                return Channel.LoadEntityGraphRecurs(cntx, _ID, excludedSets, futherDrillSets);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///  Load a selected entity graph from the data source starting at an entity having specified primary key(s): { <see cref="EventLog.ID" /> }. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="EventLog.ID" />.</param>
        /// <param name="excludedSets">A list of sets to be excluded. </param>
        /// <param name="futherDrillSets">A list of sets above the entry set that are to be drilled down futher (see the following). </param>
        /// <remarks>
        /// <para>Relational databases are designed to serve as data query and storage backend, in a normalized way, for certain kind of applications. 
        /// However at the application level, normalized elementary data sets are often combined (jointed) in a user friendly way as views. In the object oriented 
        /// world and at the data view model level, these views can be represented using entity graphs.</para>
        /// <para>This method is designed to load a selected sub entity graph recursively from the data source in one call to the service starting with a given entity (id).
        /// It could be used to increase performance and to reduce client code complexity, sometimes significantly.</para>
        /// <para>The selection is controlled by two parameters, namely <paramref name="excludedSets" /> and <paramref name="futherDrillSets" />.</para>
        /// <para>The <paramref name="excludedSets" /> parameter is used to exclude a list of entity sets and all other sets that depend on it. This can be
        /// better understood if one has a look at the schematic view of the data set schema that is shown on the front page of the data service, namely
        /// if one date set (node) is excluded then all the sets that it points to will not be reached through it, although some of them could still be reached
        /// following other routes. </para>
        /// <para>There are many ways an entity sub-graph can be loaded, the present implementation is based on the rule to be given next. Namely, starting from 
        /// the entry element, it loads all entities that depends on it, recursively downward (namely following the arrows in the schema view). It also loads all 
        /// elements that any of the elements visited by the downward recursion depends upon, recursively upward (namely in 
        /// the opposite direction of the arrows in the schema view), but never go downward again without explicit instruction.</para>
        /// <para>The <paramref name="futherDrillSets" /> parameter is used control when to go downward again, represented by the <see cref="EntitySetRelation.SetType" /> member 
        /// and the collection of data sets that depend on it, represented by the <see cref="EntitySetRelation.RelatedSets" /> member, should be further drilled down, recursively.</para>
        /// <para>Note that a data service has intrinsic limits that do not allow transmitting an entity graph that is too large in one call, so one has to select which part
        /// of the entire graph should be loaded in each call to the data service,</para>
        /// <para>For a given entity, the entities that it depends upon are represented by the member objects corresponding to each foreign keys. However, the
        /// sets of entities that depend on the said entity are stored into the corresponding collection members having the "Changed" prefix and
        /// these entities do not have a back reference to the said entity to avoid circular references when doing serialization, Such back references can be
        /// added after the graph is materialized on the clients side, if needed.</para>
        /// </remarks>
        /// <returns>
        ///   Null or the entity graph found.
        /// </returns>
        public async System.Threading.Tasks.Task<EventLog> LoadEntityGraphRecursAsync(CallContext cntx, string _ID, EntitySetType[] excludedSets, EntitySetRelation[] futherDrillSets)
        {
            try
            {
                return await Channel.LoadEntityGraphRecursAsync(cntx, _ID, excludedSets, futherDrillSets);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///  Load a set entities from the entity set having specified intrinsic ids: { <see cref="EventLog.ID" /> }. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Intrinsic id <see cref="EventLog.ID" />.</param>
        /// <remarks>
        ///  <para>
        ///   The returned entity set should contain zero or one item or null.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Null or zero or one entity.
        /// </returns>
        public List<EventLog> LoadEntityByNature(CallContext cntx, string _ID)
        {
            try
            {
                var list = Channel.LoadEntityByNature(cntx, _ID);
                return list == null ? null : list.Select(d => { d.StartAutoUpdating = true; return d; }).ToList();
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///  Load a set entities from the entity set having specified intrinsic ids: { <see cref="EventLog.ID" /> }. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Intrinsic id <see cref="EventLog.ID" />.</param>
        /// <remarks>
        ///  <para>
        ///   The returned entity set should contain zero or one item or null.
        ///  </para>
        /// </remarks>
        /// <returns>
        ///   Null or zero or one entity.
        /// </returns>
        public async System.Threading.Tasks.Task<List<EventLog>> LoadEntityByNatureAsync(CallContext cntx, string _ID)
        {
            try
            {
                var list = await Channel.LoadEntityByNatureAsync(cntx, _ID);
                return list == null ? null : list.Select(d => { d.StartAutoUpdating = true; return d; }).ToList();
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///  Load the delay loaded property <see cref="EventLog.ExceptionInfo" />. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="EventLog.ID" />.</param>
        /// <remarks>
        /// </remarks>
        /// <returns>
        ///   The value of the property.
        /// </returns>
        public string LoadEntityExceptionInfo(CallContext cntx, string _ID)
        {
            try
            {
                return Channel.LoadEntityExceptionInfo(cntx, _ID);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///  Load the delay loaded property <see cref="EventLog.ExceptionInfo" />. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="EventLog.ID" />.</param>
        /// <remarks>
        /// </remarks>
        /// <returns>
        ///   The value of the property.
        /// </returns>
        public async System.Threading.Tasks.Task<string> LoadEntityExceptionInfoAsync(CallContext cntx, string _ID)
        {
            try
            {
                return await Channel.LoadEntityExceptionInfoAsync(cntx, _ID);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///  Load the delay loaded property <see cref="EventLog.MessageLong" />. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="EventLog.ID" />.</param>
        /// <remarks>
        /// </remarks>
        /// <returns>
        ///   The value of the property.
        /// </returns>
        public string LoadEntityMessageLong(CallContext cntx, string _ID)
        {
            try
            {
                return Channel.LoadEntityMessageLong(cntx, _ID);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///  Load the delay loaded property <see cref="EventLog.MessageLong" />. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="_ID">Primary key <see cref="EventLog.ID" />.</param>
        /// <remarks>
        /// </remarks>
        /// <returns>
        ///   The value of the property.
        /// </returns>
        public async System.Threading.Tasks.Task<string> LoadEntityMessageLongAsync(CallContext cntx, string _ID)
        {
            try
            {
                return await Channel.LoadEntityMessageLongAsync(cntx, _ID);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///  Given the current sorter expression <paramref name="sorters" />, it returns the next sorter token options. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="sorters">Sorter expression tokens.</param>
        /// <returns>
        ///   A list of possible sort tokens.
        /// </returns>
        public TokenOptions GetNextSorterOps(CallContext cntx, List<QToken> sorters)
        {
            try
            {
                return Channel.GetNextSorterOps(cntx, sorters);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///  Given the current sorter expression <paramref name="sorters" />, it returns the next sorter token options. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="sorters">Sorter expression tokens.</param>
        /// <returns>
        ///   A list of possible sort tokens.
        /// </returns>
        public async System.Threading.Tasks.Task<TokenOptions> GetNextSorterOpsAsync(CallContext cntx, List<QToken> sorters)
        {
            try
            {
                return await Channel.GetNextSorterOpsAsync(cntx, sorters);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        /// <summary>
        ///  Given the current query expression <paramref name="qexpr" />, it returns the next filter token options. 
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="qexpr">The current query expression.</param>
        /// <param name="tkstr">Partial user input to filter the options further. It is not used on the service side in the current version of the system.</param>
        /// <returns>
        ///   A list of possible filter tokens.
        /// </returns>
        public TokenOptions GetNextFilterOps(CallContext cntx, QueryExpresion qexpr, string tkstr)
        {
            try
            {
                return Channel.GetNextFilterOps(cntx, qexpr, tkstr);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }

#if SUPPORT_ASYNC
        /// <summary>
        ///  Given the current query expression <paramref name="qexpr" />, it returns the next filter token options. Awaitable asynchronous version.
        /// </summary>
        /// <param name="cntx">Authenticated caller context object. If cannot be null.</param>
        /// <param name="qexpr">The current query expression.</param>
        /// <param name="tkstr">Partial user input to filter the options further. It is not used on the service side in the current version of the system.</param>
        /// <returns>
        ///   A list of possible filter tokens.
        /// </returns>
        public async System.Threading.Tasks.Task<TokenOptions> GetNextFilterOpsAsync(CallContext cntx, QueryExpresion qexpr, string tkstr)
        {
            try
            {
                return await Channel.GetNextFilterOpsAsync(cntx, qexpr, tkstr);
            }
            catch (Exception ex)
            {
                HandleError(ex);
                return null;
            }
        }
#endif

        private void HandleError(Exception ex)
        {
            if (DelHandleError != null)
                DelHandleError(ex);
            else
                throw new Exception("server exception", ex);
        }
    }
}